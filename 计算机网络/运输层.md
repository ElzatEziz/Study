#  运输层



**为什么需要运输层？**

网络层最终解决的问题：

> 分组从一台主机经过网络到达另一台主机，即主机到主机间的通信

网络层没有解决的问题：

> 主机中谁发送的数据，谁接受数据？
>
> IP分组无序到达目的主机，接受进程如何处理？
>
> 可靠传输问题



从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最底层。

只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分的路由器在转发分组时都只用到下三层的功能。



## 运输层协议概述

### 1.进程之间的通信

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2020.58.34.png)



**运输层的作用**

运输层提供进程之间的逻辑通信

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2021.09.49.png)



**屏蔽作用**

运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），使应用进程看见的就是好像在两个运输层的实体之间有一条端到端的逻辑通信信道。

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2021.52.47.png)



**进程之间通信**

严格的讲，两台主机进行通信就是两台主机中的应用程序互相通信；

从运输层的角度看，通信的真正端点并不是主机，而是主机中的进程，也就是说，端到端的通信是应用进程之间的通信



**网络层和运输层的区别**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2021.54.42.png)



**运输层复用和分用**

在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信

- 表明运输层又一个很重要的功能
  - 复用（multiplexing）
  - 分用（demultiplexing）

根据应用程序的不同需求，运输层需要有两种不同的协议

- 面向连接的TCP
- 无连接的UDP

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2021.57.47.png)



**TCP与UDP（逻辑信道的差异性）**

运输层的逻辑通信信道差别：

- 当运输层采用面向连接的TCP协议时，尽管下面的网路是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道
- 当运输层采用无连接的UDP协议时，这种通信信道是一条不可靠的信道

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.01.07.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.01.28.png)



### 2.运输层的两个主要协议

互联网正式标准：

- 用户数据报协议UDP（User Datagram Protocol）
- 传输控制协议TCP（Transmission Control Protocol）



**运输协议数据单元**

- 两个对等实体在通信时传送的数据单元叫做运输协议数据单元TPDU（Transport Protocol Data Unit）
- TCP传送的数据单位协议是TCP报文段
- UDP传送的数据单位协议是UDP报文或用户数据报



**UDP和TCP的区别**

UDP

- 传送数据之间不需要先建立连接
- 收到UDP报后，不需要给出任何确认
- 不提供可靠交付，但是一种最有效的工作方式

TCP

- 提供可靠的、面向连接的运输服务
- 不提供广播或多播服务
- 开销较多



**UDP和TCP协议特点**

UDP

- 不需要先建立连接，提供无连接服务
- 协议数据单元为UDP报文或用户数据报
- 收到UDP报文后，无序任何确认
- 简单，支持单播，多播，广播
- 适用于多媒体应用

TCP

- 提供面向连接的服务
- 传送的数据单位协议时TCP报文段
- TCP不提供广播或多播服务
- 收到TCP报文后，需要确认
- 协议复杂、开销大，占用较多的处理机资源
- 应用较多：万维网，电子邮件，文件传送等



**使用UDP和TCP的典型应用和应用层协议**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.09.59.png)



**注意**

运输层的UDP用户数据报与网际层的IP数据报有很大区别：

- IP数据报要经过互联网中许多路由器存储转发
- UDP用户数据报时在运输层的端到端抽象的逻辑信道中传送的

TCP报文段是在运输层抽象的端到端逻辑通信信道中传送的：

- 这种信道是可靠的全双工信道
- 这种信息不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了TCP连接



### 3.运输层的端口

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.13.45.png)

**为什么需要运输层的端口？**

- 为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对TCP/IP体系的应用进程进行标志
- 运行在计算机中的进程使用进程标识符来标志的
- 但应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符
- 双方不知道对方的进程，只知道对方提供什么功能



**需要考虑的问题**

- 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程
- 有时我们会改换接受报文的进程，但并不需要通知所有发送方
- 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程
- 解决这个问题的方法就是在运输层使用协议端口号（protocol prot number）
- 通信的终点是应用进程，但可以把端口想象是通信的终点，只要把要传送的报文交到目的主机的目的端口，剩下的工作（即最后交付的进程）由TCP来完成。



**端口号**

- 端口用一个16位端口号进行标志，允许有65535个不同端口号
- 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程
- 两个计算机中的进程要互相通信，不仅必须知道对方的IP地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.25.39.png)



**软件端口与硬件端口**

软件端口：

- 协议层间的抽象的协议端口
- 是应用层的各种协议进程与传输实体进行层间交互的地点
- 不同系统实现端口的方法可以不同

硬件端口：

- 不同硬件设备进行交互的接口



**两大类，三种类型的端口号**

服务器使用的端口号

- 熟知端口
  - 数值一般为0～1023（全世界都知道的）
- 登记端口
  - 数值为1024～49151
  - 给没有熟知端口号的应用程序使用的。使用这个范围的端口必须在IANA登记，以防止重复

客户端使用的端口号

- 又称为短暂端口
  - 数值为49152～65535，留给客户进程暂时使用
  - 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后，这个端口号可以供其他客户进程以后使用

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.32.10.png)



常用的熟知端口

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.34.14.png)



## 用户数据报协议UDP

### 1.UDP概述

- UDP只在IP的数据报服务之上增加了一些功能：
  - 复用和分用的功能
  - 差错检测的功能
- 虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.36.23.png)



**UDP的主要特点**

1. 无连接。
   - 发送数据之前不需要建立连接
2. 使用尽最大努力交付
   - 即不保证可靠交付
3. 面向报文。
   - UDP一次传送和交付完成一个完整的报文，保留原始报文的边界
4. 没有拥塞控制。
   - 网络出现拥塞不会使源主机的发送速率降低，很适合多媒体通信的要求
5. 支持一对一，一对多，多对一，多对多等交互通信
6. 首部开销小，只有8字节



**UDP是面向报文的**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.38.59.png)

应用层产生的数据交给UDP，UDP打包并并直接送到网络层

应用程序必须选择合适大小的报文（IP数据报最大65535有20个字节的固定部分）

- 若报文太长，IP层在传送时可能要进行分片，降低IP层的效率
- 若报文太短，会使IP数据报的首部的相对长度太大，降低IP层的效率



**UDP基于端口的分用**

- 接收方UDP根据首部中的目的端口号，把报文通过相应的端口上交给应用程序
- 如果接受方UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程）就丢弃该报文，并用ICMP发送“端口不可达”差错报文给发送方



**UDP协议使用的场景**

- 可以重复请求信息的情况下：
  - 例如DNS，DHCP，RIP
- 一次性传小量数据的应用
- 实时应用
  - IP电话、视频会议
  - 多媒体应用 

### 2.UDP的首部格式

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.51.15.png)



> UDP会对整个数据进行检验，首先对首部进行检查。这里的伪首部主要是为了去计算检验和
>
> ![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.53.04.png)



**伪首部**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.54.11.png)



**计算UDP检验和的例子**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.55.55.png)



**UDP抓包（DNS查询）**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.56.45.png)





## 传输控制协议TCP概述

### 1.TCP最主要的特点

TCP是面向连接的运输层协议，在无连接的、不可靠的IP网络服务基础之上提供可靠交付的服务。为此，在IP的数据报服务基础之上，增加了保证可靠性的一系列措施

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2022.59.44.png)



特点：

- TCP是面向连接的运输层协议
- 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接只能是点对点的（一对一）
- TCP提供可靠交付的服务
- TCP提供全双工通信
- 面向字节流
  - TCP中的“流”（stream）指的是流入或流出进程的字节序列
  - 面向字节流：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流



**面向连接的概念**

面向连接的电路交换（物理层保证可靠）：

- 通信双方之间必须有一条物理连接的通路（直接相连），且被通信双方独享，数据按序发送并按序接受

面向连接的虚电路（网络层保证可靠）

- 通信双方采用复用技术，逐段占用物理通路，每段物理通路可被多对通信使用，分组按序发送并按序接受

面向连接TCP（运输层协议保证可靠）

- 采用协议的方法（确认、序号、重传），确保通信双方有一条全双工、可靠的逻辑信道（事实上，提供服务的IP数据报是不可靠的），字节按序发送并按序接受（但网络层IP数据报并不一定按序到达）



**TCP面向流的概念**

- TCP不保证接受方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系
- 但接受方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.23.12.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.24.45.png)



### 2.TCP的连接

TCP把连接作为最基本的抽象

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.25.57.png)

> TCP连接的端点不是主机，不是主机的IP地址，不是应用程序，也不是运输层的协议端口，而是套接字



**套接字**

端口号拼接到IP地址即构成了套接字

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.27.47.png)



每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.28.46.png)



**TCP连接，IP地址，套接字**

- TCP连接就是由协议软件所提供的一种抽象
- TCP连接的端点是抽象的套接字，即（IP地址：端口号）
- 同一个IP地址可以有多个不同的TCP连接（客户端）
- 同一个端口号也可以出现在不同的TCP连接中（服务器端）





## 可靠传输的原理

### 1.停止等待协议

**IP网络提供的是不可靠的传输**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.37.59.png)



**理想传输的特点**

1. 传输信道不产生差错
2. 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据

> - 在理想传输条件下，不需要采取任何措施就能够实现可靠传输
> - 但实际网络都不具备理想传输条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。



**停止等待协议**

- 每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组（TCP报文段，其中封装的是编好号的字节）
- 全双工通信的双方即是发送方也是接受方
- 为了方便讨论问题：假设仅考虑A发送数据，而B接受数据并发送确认，因此A叫做发送方，而B叫做接受方。



1.无差错情况

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.45.59.png)



2.出现差错

- 在接受方B会出现两种情况
  - B接受M1时间错除了差错，就丢弃M1，其他什么也不做（不通知A收到有差错的分组）
  - M1在传输过程中丢失了，这时B当然什么也都不知道，也什么都不做
- 在这两种情况下，B都不会发送任何信息



那么问题：A如何知道B是否收到了M1呢？

解决方法：超时重传

- A为每一个已发送的分组设置一个超时计时器
- A只要在超时计时器到期之前收到了相应的确认，就撤销该超市计时器，继续发送下一个分组M2
- 若A在超时计时器规定的时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组



注意事项：

- A发送完一个分组后，必须暂停保留已发送的分组的副本
- 分组和确认分组都进行编号。这样才能明确哪一个是发送出去的分组收到了确认，而哪一个分组还没有收到确认
- 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些
- 超时重传时间设置问题：
  - 不能太长
  - 也不能太短

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.51.12.png)



3.确认丢失和确认迟到

确认丢失

- 若B所发送的对M1的确认丢失了，那么A在设定的超时重传时间内将不会收到确认，因此A在超时计时器到期后重传M1
- 假定B正确收到了A重传的分组M1。这时B应采取两个行动
  - 丢弃这个重复的分组M1，不向上层交付
  - 向A发送确认

确认迟到

- B对分组M1的确认迟到了，因此A在超时计时器到期后重传M1
- B会收到重复的M1，丢弃重复的M1，并重传确认分组
- A会收到重复的确认。对重复的确认处理：丢弃

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-08%2023.54.16.png)



**自动重传请求ARQ**

- 通常A最终总是可以收到对所有发出的分组的确认
- 如果A不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信
- 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信
- 传输协议常称为自动重传请求ARQ（Automtic RepeatreQuest）。意思是重传的请求时自动进行的，接收方不需要请求发送方重传某个出错的分组



4.信道利用率

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.18.40.png)



**停止等待协议的要点**

- 停止等待
  - 发送方每次只发送一个分组。在收到确认后再发送下一个分组
- 暂存
  - 再发送完一个分组后，发送方必须暂存已放松的分组的副本，以备重发
- 编号
  - 对发送的每个分组和确认都进行编号
- 超时重传
  - 发送方为发送的每个分组设置一个超时计时器。若超时计时器超时未收到确认，发送方会自动超时重传分组
- 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些，防止不必要的重传
- 简单，但信道利用率低



**提高传输效率：流水线传输**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.21.27.png)





### 2.连续ARQ协议

- 为了解决发送方和接收方能力不同的问题采用连续ARQ协议
- 发送窗口
  - 发送方维持一个发送窗口，位于发送窗口内的分组都可以被连续发送出去，而不需要等待对方的确认
- 发送窗口滑动：
  - 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置
- 累计确认
  - 接收方对按序到达的最后一个分组发送确认，表示：到这个分组为止的所有分组都已正确收到
- 采用回退N（Go-Back-N）方法进行重传
  - 表示需要再退回来重传已发送过的N个分组。



**发送窗口**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.24.16.png)



**累计确认**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.25.12.png)

优点：

- 容易实现，即使确认丢失也不必重传

缺点：

- 不能向发送方反应出接收方已经正确收到的所有分组的信息（给发送方返回发送连续分组最后一个确认）

> 当通信线路质量不好时，连续ARQ协议会带来负面影响



Go-Back-N

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.27.33.png)



**连续ARQ协议与停止等待协议对比**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2000.28.13.png)



## TCP报文段的首部格式

- TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段
- 一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用
- TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。





![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.16.27.png)

- 源端口和目的端口：
  - 各占2字节。
  - 端口是运输层与应用层的服务接口
  - 运输层的复用和分用功能通过端口实现
- 序号（seq）：
  - 占4字节
  - TCP连接中传送的数据流的每一个字节都有一个序号。
  - 序号字段的值则指的是本报文段所发送的数据的第一个字节序号
  - 序号的范围是[0,2^23-1]，序号用完后从0开始循环
  - <img src="https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.21.10.png" style="zoom:50%;" />
- 确认号（ack）
  - 占4字节，是期望收到对方的下一个报文段的第一个字节的序号
  - 若确认号=N，则表明：到序号N-1为止的所有数据都以正确收到
- 数据偏移（即首部长度）：
  - 占4字节
  - 指出TCP报文段的数据起始处距离TCP报文段的起始处有多远
  - 单位是32字节（以4字节为计算机单位1:4），最大60字节
- 保留：
  - 占6字节，保留为今后使用，但目前应置为0
- 紧急URG：
  - 控制位
  - 当UGR=1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）
- 确认ACK：
  - 控制位
  - 只有当ACK=1时，确认号字段才有效。当ACK=0时，确认号无效
- 推送PSH（PuSH）：
  - 控制位。接口TCP收到PSH=1的报文段后，就尽快（即“推送”向前）交付接受应用进程，而不再等到整个缓存都填满后再交付
- 复位RST（ReSeT）：
  - 控制位。
  - 当RST=1时，表明TCP连接中出现严重差错（如主机奔溃或其他原因），必须释放连接，然后重新建立运输连接
- 同步SYN（SYNchronization）
  - 控制位
  - 同步SYN=1，表示这是一个连接请求或连接接受报文
  - 当SYN=1，ACK=0时，表明这是一个连接 请求 报文段
  - 当SYN=1，ACK=1时，表明这是一个连接 接受 报文段
- FIN（FINish）
  - 控制位
  - 用来释放一个连接
  - FIN=1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接
- 窗口：
  - 占2字节，范围是[ 0 , 2^16 -1 ]
  - 窗口值告诉对方：从报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）
- 检验和
  - 占2字节
  - 检验和字段检验的范围包括首部和数据两部分
  - 在计算检验和时，要在TCP报文段的前面加上12字节的伪首部
- 紧急指针
  - 占2字节
  - 在URG=1时，指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），指出了紧急数据的末尾在报文段中的位置
- 选项
  - 长度可变，最长可达40字节
- 填充
  - 使整个TCP首部长度是4字节的整数倍



**有关选项的知识点**

选项（2）：最大报文段MSS

- 最大报文段长度MSS（Maximum Segment Size）是每个TCP报文段中的数据字段的最大长度
- 与接受窗口值没有关系

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.40.42.png)



MSS的长度

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.40.55.png)



选项（3）：窗口扩大

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.41.59.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.42.14.png)



选项（8）：时间戳

- 占10字节。最主要的两个字段：
  - 时间戳字段（4字节）
  - 时间戳回送回答字段（4字节）
- 两个主要功能
  - 计算往返时间RTT
  - 防止序号绕回PAWS（Project Against Wrapped Sequence numbers）
    - 序号重复时，为了使接收方能够把新报文段和迟到很久的旧报文段区分开，可以在报文段中加上时间戳

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.44.46.png)

时间戳抓包

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.45.07.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.45.18.png)



## TCP可靠传输的实现

### 1.以字节为单位的滑动窗口

- TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输
- TCP的滑动窗口是以字节为单位的
- 发送方A和接收方B分别维持一个发送窗口和一个接受窗口
  - 发送窗口：
    - 在没有收到确认的情况下，发送方可以连续把窗口内的数据全部发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用
  - 接受窗口：按序到达但未被应用程序接受的数据、不按序到达的数据



TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段的

- TCP两端的四个窗口经常处于动态变化之中
- TCP连接的往返时间RTT不是固定不变的，需要使用特定的算法估算较为合理的重传时间



**发送窗口**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.50.38.png)

>  A可以把落入发送窗口中的序号字节一次连续性全部发送出去：边发送边接受确认

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.53.33.png)



**接受窗口**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.54.35.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.55.17.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.55.33.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.56.21.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.57.35.png)



**接收方发送确认的时机**

接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上

注意两点：

- 第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传
- 第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据



**发送缓存与发送窗口**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2018.59.52.png)



**接受缓存与接受窗口**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.00.16.png)



**需要强调三点**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.00.41.png)



### 2.超时重传时间的选择

- TCP发送方在规定的时间内没有收到确认就要重传已发送的报文段
- 但重传时间的选择是TCP最复杂的问题之一
- 互联网环境复杂，IP数据报所选择的路由变化很大，导致运输层的往返时间RTT的变化也很大

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.02.02.png)



**TCP超时重传时间设置**

- 不能太短，否则会硬气很多报文段的不必要的重传，使网路负荷增大
- 不能过长，会使网络的空闲时间增大，降低了传输效率

> TCP采用了一种自适应算法，它记录一个报文段发送的时间，以及收到相应确认的时间
>
> 这两个时间之差就是报文段的往返时间RTT



**加权平均往返时间RTTs**

- TCP保留了RTT的一个，加权平均往返时间RTTs又称为平滑的往返时间
- 第一次测量到RTT样本时，RTTS值就取为所测量到的RTT样本值
- 以后每测量一个新的RTT样本，就按下式重新计算一次RTTS：
  - ![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.05.51.png)



**超时重传时间RTO**

- RTO（Retransmission Time-Out）应略大于加权平均往返时间RTTs
- RFC6298的建议RTO：
  - RTO=RTTs + 4 * RTTd
    - RTTd是RTT偏差的加权平均值
- 第一次测量时，RTTD值取为测量到的RTT样本值的一半，在以后的测量中，则是用下式计算RTTD：
  - ![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.07.47.png)



往返时间RTT的测量相当复杂

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.08.17.png)



**Karn（卡恩）算法**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.08.51.png)

**修正的Karn算法**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.09.11.png)



### 3.选择确认SACK

问题：

若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？

解决方法：选择确认SACK（Selective ACK）



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.13.39.png)



**RFC2018对SACK的规定**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.14.17.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.14.29.png)



**SACK**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.14.44.png)



## TCP的流量控制

### 1.利用滑动窗口实现流量控制

- 流量控制（flow control）：让发送方的发送速率不要太快，使接收方来得及接受。
- 利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制



**利用可变窗口进行流量控制举例**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.17.00.png)



**可能发生死锁**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2019.17.29.png)



**持续计时器**

![截屏2022-12-09 19.17.48](/Users/elzat/Library/Application Support/typora-user-images/截屏2022-12-09 19.17.48.png)



### 2.TCP的传输效率

控制TCP发送报文段的时机：三种机制

1. TCP维持一个变量，它等于最大报文长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去
2. 由发送方的应用进程指明要求发送报文段，即TCP支持的推送（push）操作
3. 发送方的一个计时器期限到了，这是就把已有的缓存数据装入报文段（但长度不能超过MSS）发送出去

> 如何控制TCP发送报文段的实际仍然是一个较为复杂的问题



**糊涂窗口综合症**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.00.54.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.01.09.png)



**发送方糊涂窗口综合症**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.01.24.png)



**Nagle算法**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.01.47.png)



**接收方糊涂窗口综合症**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.02.42.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.02.51.png)



## TCP的拥塞控制



### 1.拥塞控制的一般原理

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.04.23.png)



**拥塞产生的原因**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.05.42.png)



**增加资源能解决拥塞吗？**

- 不能，而且还可能使网络的性能更坏
- 例如：
  - 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞
  - 提高处理机处理的速率会讲瓶颈转移到其他地方
  - 拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞



**拥塞常常趋于恶化**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.44.46.png)



**拥塞控制与流量控制的区别**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.45.18.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.45.46.png)



**拥塞控制的一般原理**

- 拥塞控制的前提：网络能够承受现有的网络负荷
- 实践证明，拥塞控制是很难设计的，因为它是一个动态问题
- 分组的丢失是网络发生拥塞的征兆，而不是原因

> 数据链路层：帧出错被丢弃
>
> 网络层：出错IP分组被丢弃

- 在许多情况下，甚至正式拥塞控制本身引起网络性能恶化，甚至发生死锁的原因



**开环控制和闭环控制**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.48.03.png)



闭环控制措施

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2020.48.55.png)



### 2.TCP的拥塞控制方法

- TCP采用基于滑动窗口的方法进行拥塞控制，属于闭环控制方法
- TCP发送方维持一个拥塞窗口cwnd（Congestion window）
- 拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的
- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量
- 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况
- 真正的发送窗口值：
  - Min（接收方通知的窗口值，拥塞窗口值）



控制拥塞窗口变化的原则

- 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，提高网路的利用率
- 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组书，缓解网络出现的拥塞



**发送方判断拥塞的发功发：隐式反馈**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.41.59.png)



**TCP拥塞控制算法**

四种拥塞控制算法

- 慢开始（slow start）
  - 每个传输轮次之后，拥塞窗口值乘2
- 拥塞避免（congestion avoidance）
  - 每收到一个确认，拥塞窗口加1（加法增大）
- 快重传（fast retransmit）
  - 收到三个连续重复确认，立即重传丢失的报文段
- 快回复（fast recovery）
  - 收到连续重复确认，门限制乘0.5，执行拥塞避免算法



### 3.主动队列管理AQM

TCP拥塞控制和网络层采取的策略有密切联系

例如：

- 若路由器对某些分组的处理时间特别长，就可能引起发送方TCP超时，对这些报文段进行重传
- 重传会使TCP连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞

对TCP拥塞控制影响最大的就是路由器的分组丢弃策略



**”先进先出“ FIFO处理规则**

先进先出（First In First Out）处理规则：

- 尾部丢弃策略：当队列已满时，以后到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃
- 路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使TCP进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送率降低到很小的数值



**先进先出处理规则与尾部丢弃策略**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.51.04.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.51.30.png)



**严重问题：全局同步**

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.52.27.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.52.10.png)



**主动队列管理**

- 1998年提出了主动队列管理AQM（Active Queue Management）
- 主动：不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组，而是在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组
- AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED（Random Early Detection）



**随机早期检测RED**

- 路由器队列维持两个参数：
  - 队列长度最小门限THmin
  - 队列长度最大门限THmax
- RED对每一个到达的分组都先计算平均队列长度Lav
  - 若平均队列长度小于最小门限THmin，则将新到达的分组放入队列进行排队
  - 若平均队列长度超过最大门限THmax，则将新到达的分组丢弃
  - 若平均队列长度介于在最小门限THmin和最大门限THmax之间，则按照某一概率p将新到达的分组丢弃

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.58.36.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.58.49.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2021.59.09.png)



## TCP的运输连接管理

### 1.TCP的连接建立

TCP时面向连接的协议

TCP连接有三个阶段：

- 连接建立：交流之前打招呼
- 数据传送：信息交流
- 连接释放：交流完成说再见

TCP的连接管理就是使TCP连接的建立和释放都能正常的进行



**TCP连接建立过程中要解决三个问题**

1. 要使每一方都能够确知对方的存在
2. 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配

> TCP连接的建立采用客户服务器方式
>
> 主动发起连接建立应用进程叫做客户
>
> 被动等待连接建立的应用进程叫做服务器



**TCP的连接建立**

- TCP建立连接的过程叫做握手
- 采用三报文握手：在客户和服务器之间交换三个TCP报文段，以防止已失效的连接请求报文段突然有传送到了，因而产生TCP连接建立错误



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.05.18.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.06.02.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.06.12.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.06.47.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.07.12.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.07.25.png)



### 2.TCP的连接释放

- TCP的连接释放过程比较复杂
- 数据传输结束后，通信的双方都可释放连接
- TCP连接释放过程时四报文挥手

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.09.17.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.09.30.png)



![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.09.43.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.11.25.png)

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.11.43.png)



**必须等待2MSL的时间**

- 第一，保证发送的最后一个ACK报文段能够到达B
- 第二，防止“已失效的连接请求报文段出现在本连接中”



**保活计时器**

- 用来防止在TCP连接出现长时期空闲
- 通常设置为2小时
- 若服务器过了2小时还没有收到客户的信息，它就发送探测报文段
- 若发送了10个探测报文段（每一个相隔75秒）还没有相应，就假定客户除了故障，因而就终止该连接





### 3.TCP的有限状态机

![](https://gitee.com/zati/img-bed/raw/master/Img2/%E6%88%AA%E5%B1%8F2022-12-09%2022.14.10.png)